<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<script>
		/* 
		ES6 문법
		4. 전개연산자(Spread Operator):
		- 나열된 자룔를 추출하거나 연산할 때 사용하는 연산자,
		- 변수명이나 객체명 앞에 (...)연산자를 사용함

		형식: ...객체명 또는 ...변수명
		반드시 배열, 객체, 함수 인자 표현식([], {}, ())안에서만 사용 가능함.

		- 배열객체 연산자: [...객체명 또는 ...변수명]
		- 객체 전개 연산자: {...객체명 또는 변수명}
		*/
		var arr1 = ['one', 'two'];
		var arr2 = ['three', 'four', 'five'];

		// 배열 합치기
		var combine = [arr1[0], arr1[1], arr2[0], arr2[1], arr2[2]];
		console.log(`배열 합치기1: ${combine}`);

		combine = [...arr1, ...arr2];
		console.log(`배열 합치기2: ${combine}`);
		console.log("===============================================");

		// 5. 구조분해할당 변수: 배열의 형식으로 선언된 변수로 구조를 분해한 값을 자동으로 할당해주는 변수
		var numArr = [10, 5, , 1, 99, 100];
		var [a, b, c = '기본값 설정', ...others] = numArr;
		// var [a, b, c = '기본값 설정', ...d] = numArr; // 가능

		// 불가 전개연산자 객체는 반드시 맨 마지막에 기술되어야 한다.
		// var [ ...others, a, b, c='기본값 설정' ] = numArr;

		// 할당된 값이 없으면 기본값 적용, 할당된 값이 있으면 해당 값으로 적용됨.
		// var [ c='기본값 설정', a, b, ...others  ] = numArr;

		console.log('numArr배열객체: ', numArr);
		console.log(`변수 a의 값는: ${a}, 자료형은 ${typeof a}`);
		console.log(`변수 b의 값는: ${b}, 자료형은 ${typeof b}`);
		console.log(`변수 c의 값는: ${c}, 자료형은 ${typeof c}`);

		console.log(`변수 others의 값는: ${others}, 자료형은 ${typeof others}`);
		console.log(`변수 others는 배열${Array.isArray(others) ? '입니다.' : '이 아닙니다.'}`);
		console.log("===============================================");

		// Object.assign(); 함수를 이용한 객체 병합 또는 새로운 객체 생성
		// 동일한 속성명은 나중의 object 객체의 값으로 덮어쓰기 되어 중복속성명이 제거되어 병합됨.
		var obj1 = { one: '하나', two: '둘', other: -1 };
		var obj2 = { three: '셋', four: '넷', five: '다섯', other: '테스트' };

		console.log('obj1 객체: ', obj1);
		console.log('obj2 객체: ', obj2);
		console.log("===============================================");

		var newObj = Object.assign(obj1, obj2); // obj1 객체로 병합. 원본이 변경됨.
		// var newObj = Object.assign({}, obj1, obj2); // obj1과 obj2를 병합하여 새로운 {} 객체로 반환함.
		console.log('obj1 객체: ', obj1);
		console.log('obj2 객체: ', obj2);
		console.log('newObj 객체: ', newObj);
		console.log("===============================================");

		// 객체 전개 연산자를 이용하여 객체 병합하기
		console.log("객체 전개 연산자를 이용하여 객체 병합하기");
		newObj = { ...obj1, ...obj2 };
		console.log('newObj 객체: ', newObj);
		console.log("===============================================");

		var { other, ...others } = newObj;
		// obj를 객체전개 연산자로 받을 경우에는 반드시 속성명과 동일하게 기술해주어야 한다.
		// 객체를 ...others로 받는 경우 새로운 object로 반환한다.
		console.log('other 객체: ', other);
		console.log('others 객체: ', others);
		console.log("===============================================");

		var obj = { 'color': 'red', 'border': 'none', 'checked': 'checked' };
		let { color, border, checked } = obj;
		console.log('obj: ', obj);
		console.log('color: ', color);
		console.log('border: ', border);
		console.log('checked: ', checked);
		console.log("===============================================");
	</script>
</head>
<body>
	<script>
		function spread(arg1, ...ttt) {
			console.log('arg1: ', arg1);
			console.log('ttt: ', ttt);
		}
		spread([1, 2, 3], 4, 5, 6);

		// 객체 확장하기
		let x = 5, y = 3;
		let item = { x, y };

		// let item = { x: x, y: y };로 선언해야 하나,
		// 속성명과 변수명이 같은 경우는 :값 형식을 생략할 수 있다.
		console.log(`item 객체의 x속성이 가지고 있는 값은 ${item.x}이며, y속성이 가지고 있는 값은 ${item.y}입니다.`);

		let items = [1, , 5];
		let it_1 = items[1] || 'empty인 경우 대신 적용될 수 있는 기본값 설정';
		console.log('items 배열: ', items);
		console.log(`it_1: ${it_1}`);
	</script>
</body>
</html>